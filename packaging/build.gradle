import com.badlogicgames.packr.Packr
import com.badlogicgames.packr.PackrConfig

import java.nio.file.Files
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream
import org.apache.commons.io.FileUtils

sonar.skipProject true

tasks.register('packageReleaseAllPlateforms') {
    dependsOn downloadJdks

    dependsOn PackrConfig.Platform.values().collect { "packr${it}" }
    dependsOn releaseHtml
    dependsOn releaseAndroid

    doFirst {
        delete {
            delete "build/output/"
        }
    }
}

tasks.register('releaseHtml', Zip) {
    dependsOn(":html:dist")

    from (project(":html").projectDir + "/build/dist")
    include "**/*"
    archiveFileName = "${getNeatVersionString()}-js.zip"
    destinationDirectory = file("release/")
}

tasks.register('releaseAndroid') {
    dependsOn(":android:assembleDebug")

    copy {
        from "${project(":android").projectDir}/build/outputs/apk/debug/android-debug.apk"
        into "release/"
        fileMode 755
        rename "android-debug.apk", "${getNeatVersionString()}.apk"
    }
}

PackrConfig.Platform.values().each { platform ->
    tasks.register("packr${platform}") {
        doFirst {
            def fileUrl = generateJdkUrl(platform.toString())
            def outputDir = file("build/jdks")

            ant {
                get(src: fileUrl, dest: outputDir)
            }
        }

        doLast {
            def artifactName = platform.toString().toLowerCase().replace("64", "")
            def outputDir = file("build/output/${artifactName}")
            def zipFile = file("${artifactName}.zip")
            def config = new PackrConfig()

            config.with {
                executable = appName
                config.platform = platform

                jdk = generateJdkUrl(platform.toString())
                classpath = [ project(":desktop").projectDir + "/build/libs/${getNeatVersionString()}.jar" ]
                mainClass = project(":desktop").ext.mainClassName

                removePlatformLibs = config.classpath
                bundleIdentifier = getPackage() + ".mac"
                outDir = outputDir

                vmArgs = []

                if (platform == PackrConfig.Platform.MacOS) {
                    vmArgs += "XstartOnFirstThread"
                    iconResource = file("$rootDir/assets/icons/brozone.icns")
                } else {
                    iconResource = file("$rootDir/asset/icons/brozone.ico")
                }
            }

            new Packr().pack(config)

            createZip(outputDir, zipFile)
        }
    }
}

tasks.register('downloadJdks') {
    PackrConfig.Platform.values().each { platform ->
        def fileName = platform.toString().toLowerCase()
        if (!file("build/jdks/${fileName}.zip").exists()) {
            def fileUrl = generateJdkUrl(platform.toString())
            def outputDir = file("build/temp")

            def downloadedFile = new File(outputDir, "${fileName}.zip")
            FileUtils.copyURLToFile(new URL(fileUrl), downloadedFile)
            FileUtils.moveFileToDirectory(downloadedFile, file("build/jdks"), true)
        }
    }
}

def createZip(File sourceDir, File zipFile) {
    ConfigurableFileTree tree = fileTree(dir: sourceDir)
    zipFile.parentFile.mkdirs()

    try (ZipOutputStream zipOutputStream = new ZipOutputStream(new FileOutputStream(zipFile))) {
        zipOutputStream.setLevel(9)
        tree.each {File file ->
            String relativePath = sourceDir.toPath().relativize(file.toPath()).toString().replace('\\', '/')
            ZipEntry zipEntry = new ZipEntry(relativePath)

            zipOutputStream.putNextEntry(zipEntry)

            if (!Files.isDirectory(file.toPath())) {
                Files.copy(file.toPath(), zipOutputStream)
            }

            zipOutputStream.closeEntry()
        }
    } catch (IOException e) {
        throw new RuntimeException("Erreur lors de la cr√©ation du fichier ZIP.", e)
    }
}