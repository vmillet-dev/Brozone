import com.badlogicgames.packr.Packr
import com.badlogicgames.packr.PackrConfig
import java.util.zip.ZipEntry

apply plugin: "org.beryx.jlink"

def ICON_PATH = new File("$rootDir/assets/badlogic.jpg")

tasks.register('releaseHtml', Zip) {
    dependsOn(":html:dist")

    from (project(":html").projectDir.path + "/build/dist")
    include "**/*"
    archiveFileName = "${getNeatVersionString()}-js.zip"
    destinationDirectory = file(project.projectDir.path + "/release")
}

tasks.register('releaseAndroid') {
    dependsOn(":android:assembleDebug")

    copy {
        from "${project(":android").projectDir.path}/build/outputs/apk"
        into "release/"
        fileMode 755
    }
}

tasks.register('analyzeDependencies') {
    doLast {
        exec {
            commandLine 'jdeps', '-R', '-cp', sourceSets.main.runtimeClasspath.asPath, sourceSets.main.output.classesDirs.files
            standardOutput = new ByteArrayOutputStream()
        }
    }
}

tasks.register('createMinimalJre', JavaExec) {
    dependsOn(":desktop:dist")
    dependsOn analyzeDependencies

    mainClassName = project(":desktop").ext.mainClassName
    classpath = sourceSets.main.runtimeClasspath

    jlink {
        imageDir = file('build/minimalJre')
        launcher {
            name = appName
        }
        jvmArgs(['-Xmx512m'])

        options = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']

        doFirst {
            def dependencies = []
            new File('build/libs/jdeps-result.txt').eachLine { line ->
                def module = line.split(' ')[1]
                dependencies.add(module)
            }

            addModules(dependencies)
        }

        targetPlatform("linux-x64") {
            jdkHome = jdkDownload(generateJdkUrl("linux")) {
                downloadDir = "$projectDir.path/jdks"
                archiveName = "${PackrConfig.Platform.Linux64.toString().toLowerCase()}-jdk"
                archiveExtension = "zip"
                overwrite = false
            }
            addOptions("--endian", "big")
            addExtraModulePath("/usr/lib/openjfx/linux-x64/jmods")
        }

        targetPlatform("win") {
            jdkHome = jdkDownload(generateJdkUrl("windows")) {
                downloadDir = "$projectDir.path/jdks"
                archiveName = "${PackrConfig.Platform.Windows64.toString().toLowerCase()}-jdk"
                archiveExtension = "zip"
                overwrite = false
            }
            addExtraModulePath("/usr/lib/openjfx/win/jmods")
        }

        targetPlatform("mac") {
            jdkHome = jdkDownload(generateJdkUrl("macos")) {
                downloadDir = "$projectDir.path/jdks"
                archiveName = "${PackrConfig.Platform.MacOS.toString().toLowerCase()}-jdk"
                archiveExtension = "zip"
                overwrite = false
            }
            addExtraModulePath("/usr/lib/openjfx/mac/jmods")
        }
    }
}

PackrConfig.Platform.values().each { platform ->
    tasks.register("packr${platform}") {
        doLast {
            def outputDir = file("build/output-${platform.toString().toLowerCase()}")
            def zipFile = file("build/release/${platform.toString().toLowerCase()}.zip")
            def config = new PackrConfig()

            config.with {
                executable = appName
                config.platform = platform

                jdk = "${projectDir.path}/jdks/${platform.toString().toLowerCase()}.zip"
                classpath = [ project(":desktop").projectDir.path + "/build/libs/${getNeatVersionString()}.jar" ]
                mainClass = project(":desktop").ext.mainClassName

                removePlatformLibs = config.classpath
                bundleIdentifier = getPackage() + ".mac"
                iconResource = ICON_PATH
                outDir = outputDir

                if (platform == PackrConfig.Platform.MacOS) {
                    iconResource = file("chemin/vers/votre/icone.icns")
                    vmArgs = ["XstartOnFirstThread"]
                } else if (platform == PackrConfig.Platform.Windows64) {
                    iconResource = file("chemin/vers/votre/icone.ico")
                }
            }

            new Packr().pack(config)

            project.delete(zipFile)
            project.zipTree(outputDir).visit { FileVisitDetails details ->
                if (details.isDirectory()) return
                def relativePath = outputDir.toPath().relativize(details.file.toPath()).toString()
                zipFile.withOutputStream { zipOutputStream ->
                    zipOutputStream.putNextEntry(new ZipEntry(relativePath))
                    Files.copy(details.file.toPath(), zipOutputStream)
                    zipOutputStream.closeEntry()
                }
            }
        }
    }
}

tasks.register('packageReleaseAllPlateforms') {
    dependsOn createMinimalJre

    dependsOn PackrConfig.Platform.values().collect { "packr${it}" }
    dependsOn releaseHtml
    dependsOn releaseAndroid
}
































//String getUrlByPlatform(PackrConfig.Platform platform) {
//    switch (platform) {
//        case PackrConfig.Platform.Windows64: return "${urlJdkWindows}"
//        case PackrConfig.Platform.MacOS: return "${urlJdkMacOs}"
//        case PackrConfig.Platform.Linux64: return "${urlJdkLinux}"
//    }
//}
//
//tasks.register('releaseAllPlatform') {
//    PackrConfig.Platform.values().each { platform ->
//        if (platform == PackrConfig.Platform.Linux64) {
//            return
//        }
//        dependsOn "zip${platform.toString()}"
//    }
//
//    dependsOn("releaseHtml")
//}
//
//tasks.register('releaseHtml', Zip) {
//    dependsOn(":html:war")
//    copy {
//        from (project(":html").projectDir.path + "/build/libs")
//        into "release/"
//    }
//
//    dependsOn(":html:dist")
//
//    from (project(":html").projectDir.path + "/build/dist")
//    include "**/*"
//    archiveFileName = "${getNeatVersionString()}-js.zip"
//    destinationDirectory = file(project.projectDir.path + "/release")
//}
//
//PackrConfig.Platform.values().each { platform ->
//    def platformName = platform.toString()
//
//    configurePackageTask(platform, ICON_PATH)
//
//    tasks.named("package${platformName}") {
//        finalizedBy "zip${platformName}"
//    }
//
//    tasks.register("zip${platformName}", Zip) {
//        dependsOn "package${platformName}"
//
//        from "build/output"
//        include "**/*"
//        archiveFileName = "${generateDesktopReleaseName(platformName)}.zip"
//        destinationDirectory = file(project.projectDir.path + "/release")
//
//        delete "build/"
//    }
//}
//
//def configurePackageTask(PackrConfig.Platform platform, ICON_PATH) {
//    tasks.register("package${platform.toString()}") {
//        dependsOn(":desktop:dist")
//
//        doLast {
//            copy {
//                into "build/"
//                rename("${appName}.jar", "desktop.jar")
//                from "build/libs/${appName}.jar"
//            }
//
//            delete {
//                delete "build/output/"
//            }
//
//            def config = new PackrConfig()
//
//            config.with {
//                config.executable = appName
//                config.platform = platform
//                verbose = true
//                bundleIdentifier = getPackage() + ".mac"
//                iconResource = ICON_PATH
//                outDir = file("build/output")
//                mainClass = project(":desktop").ext.mainClassName
//                classpath = [ project(":desktop").projectDir.path + "/build/libs/${getNeatVersionString()}.jar" ]
//                removePlatformLibs = config.classpath
//
//                jdk = configureJdk(platform)
//
//                vmArgs = []
//                minimizeJre = "$rootDir/packaging/packr_minimize.json".toString()
//
//                if (platform == PackrConfig.Platform.MacOS) {
//                    vmArgs += "XstartOnFirstThread"
//                }
//            }
//
//            new Packr().pack(config)
//
//            copyOutputFiles(platform)
//        }
//    }
//}
//
//def configureJdk(PackrConfig.Platform platform) {
//    if (!activeJdkCache) {
//        return getUrlByPlatform(platform)
//    }
//
//    def jdkZip = new File(project.projectDir.path + "/cache/${platform.toString().toLowerCase()}" + "/jdk.zip")
//    if (!jdkZip.exists()) {
//        download.run {
//            src getUrlByPlatform(platform)
//            dest jdkZip
//            overwrite true
//        }
//    }
//
//    return jdkZip.getAbsolutePath()
//}
//
//def copyOutputFiles(platform) {
//    if (platform != PackrConfig.Platform.MacOS) {
//        copy {
//            into "build/output/jre/"
//            from "build/output/desktop.jar"
//        }
//
//        delete {
//            delete "build/output/desktop.jar"
//        }
//
//        file("build/output/${appName}.json").text = file("build/output/${appName}.json").text.replace("desktop.jar", "jre/desktop.jar")
//    }
//
//    if (platform == PackrConfig.Platform.MacOS) {
//        copy {
//            into "build/output/${appName}.app/Contents/"
//            from "build/output/Contents/"
//        }
//
//        delete {
//            delete "build/output/Contents/"
//        }
//    }
//
//    if (platform == PackrConfig.Platform.Windows64) {
//        copy {
//            from "build/output/jre/bin/msvcr100.dll"
//            into "build/output/"
//            rename("msvcr100.dll", "MSVCR100.dll")
//        }
//    }
//
//    copy {
//        from "build/output"
//        into "deploy/${platform.toString().toLowerCase()}"
//        fileMode 755
//    }
//}

sonar {
    skipProject true
}